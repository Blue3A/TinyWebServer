
定时器处理非活动连接
===============
由于非活跃连接占用了连接资源，严重影响服务器的性能，通过实现一个服务器定时器，处理这种非活跃连接，释放连接资源。利用alarm函数周期性地触发SIGALRM信号,该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务.
> * 统一事件源
> * 基于升序链表的定时器
> * 处理非活动连接

统一事件源
---------
信号是一种异步事件:信号处理函数和程序的主循环是两条不同的执行路线。一种典型的解决方案是：把信号的主要处理逻辑放到程序的主循环中，当信号处理函数被触发时，它只是简单地通知主循环程序接收到信号，并把信息值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。

信号处理函数通常使用管道来将信号传递给主循环：
> * 信号处理函数往管道的写端写入信号值
> * 利用I/O复用系统监听管道读端文件描述符的可读事件
> * 主循环则从管道的读端读出该信号值


基于升序链表的定时器
----------
升序定时器链表将其中的定时器按照超时时间做升序排列.

工作流程
> * 创建空定时器链表,设定时间
> * 客户端连入,创建对应定时器,初始化数据后添加到链表中
> * SIGALRM信号触发,调用心跳函数,循环定时器链表查看是否有任务超时
> * 该客户端在设定时间内有数据收发,则当前时刻对该定时器重新设定时间
> * 该客户端在超时事件内没有数据收发,则超时断开

用户数据结构
> * 客户端地址
> * 文件描述符
> * 读缓存
> * 定时器

定时器类
> * 任务超时时间, (连接时间或数据发送时间)+设定时间
> * 回调函数, 这里为关闭连接
> * 客户数据类, 每个定时器为客户特有
> * 指向前一个定时器
> * 指向后一个定时器

定时器链表功能
添加定时器的事件复杂度是O(n),删除定时器的事件复杂度是O(1)
> * 双向链表,带头尾节点,方便调整
> * add_timer函数将目标定时器添加到链表中
> * adjust_timer函数当定时任务发生变化,调整对应定时器在链表中的位置
> * del_timer函数将超时的定时器从链表中删除
> * tick心跳函数,从头结点开始依次处理每个定时器,直到遇到尚未到期的定时器

心跳函数
> * 遍历定时器链表从头结点开始依次处理每个定时器,直到遇到尚未到期的定时器
> * 若当前时间小于定时器设定时间,跳出循环,即找到未到期的定时器
> * 否则,执行回调函数,然后将它从链表中删除

处理非活动连接
-----------
利用alarm函数周期性地触发SIGALRM信号,该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务.

### 工作流程

* 创建管道,将管道写端设置为非阻塞,将管道读端添加到epoll内核事件表

    * 非阻塞是防止读端未及时读,而导致写不进去
    
* addsig函数设置捕获的信号类型:SIGALRM,SIGTERM

    * 设置sid_handler回调函数,通过管道读端将捕获到的信号名发送给主循环
    
* alarm定时

    * alarm定时只会触发一次SIGALRM信号,捕获后需要重新定时
    
* epoll_wait监听事件发生

    * 若是监听描述符,建立连接,创建定时器,将其添加到定时器链表
    
    * 非监听描述符,先判断是否是管道读端,根据读到的信号类型,设置对应参数
    
    * 处理客户连接上的数据,若发生读错误或对方关闭连接,则移除对应定时器
    
    * 若客户连接有数据读写,延长定时器的设定时间
    
* 处理定时事件,因为I/O事件有更高的优先级,但这样会导致定时任务时间不精确





