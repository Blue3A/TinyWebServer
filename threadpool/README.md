
半同步/半反应堆线程池
===============
使用一个工作队列完全解除了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工作线程通过竞争来取得任务并执行它。
> * Reactor模式
> * 半同步/半反应堆
> * 线程池

Reactor模式
---------
主线程(I/O处理单元)只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程(逻辑单元)。除此之外，主线程不做任何其他实质性的工作。读写数据,接收新连接以及处理客户请求均在工作线程中完成.

同步I/O和异步I/O模型
> * 同步I/O是指内核向应用程序通知的是就绪事件，比如只通知有客户端连接
> * 异步I/O是指内核向应用程序通知的是完成事件，比如读取客户端的数据后才通知应用程序

同步I/O模型的工作流程如下（epoll_wait为例）：
> * 主线程往epoll内核事件表注册socket上的读就绪事件。
> * 主线程调用epoll_wait等待socket上有数据可读
> * 当socket上有数据可读，epoll_wait通知主线程,主线程则将socket可读事件放入请求队列。
> * 睡眠在请求队列上某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件
> * 主线程调用epoll_wait等待socket可写。
> * 当socket上有数据可写，epoll_wait通知主线程。主线程则将socket可写事件放入请求队列。
> * 睡眠在请求队列上某个工作线程被唤醒，它从socket写入服务器处理客户请求的结果

Proactor模式
----------


半同步/半反应堆
----------
半同步/半反应堆并发模式是半同步/半异步的变体，将半异步具体化为Reactor模式.

并发模式中的同步和异步
> * 同步指的是程序完全按照代码序列的顺序执行
> * 异步指的是程序的执行需要由系统事件驱动

半同步/半异步模式工作流程
> * 同步线程用于处理客户逻辑
> * 异步线程用于处理I/O事件
> * 异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中
> * 请求队列将通知某个工作在**同步模式的工作线程**来读取并处理该请求对象

半同步/半反应堆工作流程
> * 主线程充当异步线程，负责监听所有socket上的事件
> * 若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件
> * 如果连接socket上有读写事件发生，主线程就将该连接socket插入到请求队列中
> * 所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权

从上可以看出，异步线程采用的是Reactor模式.

线程池
-----------
空间换时间,浪费服务器的硬件资源,换取运行效率.

池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.

### 设计思路

* 创建固定数量的线程

    * 构造函数中创建线程池,pthread_create函数中将类的对象(this)作为参数传递给静态函数(worker),在静态函数中引用这个对象,并调用其动态方法(run)
    
* 信号量sem m_queuestat提醒是否有任务要处理

* 向请求队列中添加任务

    * 通过list容器创建请求队列
    
    * 向队列中添加时,通过互斥锁保证线程安全
    
    * 添加完成后通过信号量提醒有任务要处理
    
* 工作静态函数

    * 调用对象,使用对象的动态方法run
    
* 动态方法run执行任务

    * 信号量等待
    
    * 被唤醒后先加互斥锁
    
    * 从请求队列中取出第一个任务,将任务从请求队列删除
    
    * process(模板类中的方法,这里是http类)进行处理






